uniform shader iChunk;

half4 main(float2 xy)
{
	//Pixel scale of shadow mask
	const half MASK_SCALE = 1;
	//Intensity of mask effect between 0 and 1
	const half MASK_INTENSITY = 0.3;
	
	//Chromatic abberration offset in pixels (0 = no aberration)
	const half2 ABERRATION_OFFSET = half2(2,0);
	
	//Intensity of scanline effect
	const half SCANLINE_INTENSITY = 0.2;
	//Scanline width in pixels
	const half SCANLINE_WIDTH = 4;
	//Scanline endpoint (should be between P1 and 1)
	const half SCANLINE_P0 = 1;
	//Scanline startpoint (should be between 0 and 1)
	const half SCANLINE_P1 = 0.2;
	
	//Round coordinates to mask cell
	float2 cell = floor(xy/MASK_SCALE);
	//Mask cell offset (shifts half a cell every other row)
	float2 cell_offset = half2(fract(cell.y/2),0);
	//Sample color for the whole mask cell
	half4 mask_color = iChunk.eval((cell+cell_offset)*MASK_SCALE);
	//Compute RGB mask index (0 == red, 1 == green, 2 == blue)
	half mask_index = mod(floor(cell.x/2+cell.y*1.5),3);
	//Blend with mask cell color
	mask_color *= half4(mask_index==0, mask_index==1, mask_index==2, 1)*3;
	
	//Sample texture with abberation offsets
	half4 aberration = iChunk.eval(xy-ABERRATION_OFFSET);
	aberration.g = iChunk.eval(xy+ABERRATION_OFFSET).g;
	
	//Oscillate between -1 and +1 for scanlines
	half scanline_ridge = abs(mod(xy.y/SCANLINE_WIDTH,2)-1);
	//Compute scanline value with approximate average of 1.
	half scanline = smoothstep(SCANLINE_P0, SCANLINE_P1, scanline_ridge) + 0.5;
	//Dampen scanline intensity amount
	scanline = mix(1, scanline, SCANLINE_INTENSITY);
	
	//Compute the aberration/mask output color
	half4 color = mix(aberration, mask_color, MASK_INTENSITY);
	//Add in scanlines
	color.rgb *= scanline;
	return color;
}
